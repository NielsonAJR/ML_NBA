---
title: "Abordagem Alternativa para a Classificação de Posições"
lang: pt
message: false
warning: false
linkcolor: black
urlcolor: black
---



```{r}
#| echo: false

library(hoopR) # Banco de Dados
library(tidyverse) # Framework do tidyverse
library(tidymodels) # Framework de modelagem
library(skimr) # Estatística descritiva rápida
library(DataExplorer) # Exploração do conjunto de dados
library(corrplot) # Gráfico de correlação
library(GGally) # Gráficos adicionais com estrutura ggplot2
library(stringr) # Para lidar com strings
library(glmnet) # LASSO, Ridge e Rede Elástica
library(MASS) # Discriminante Linear (LDA) e Quadrático (RL)
library(recipes) # Pré-processamento dos dados
library(class) #knn
library(themis) # Balanceamento de dados
library(discrim) # lda, qda
library(kknn) # (Kernel) K-NN
library(finetune) # Otimização fina de hiperparâmetros
library(gt)
library(naivebayes)
library(knitr)
library(corrplot)


ggplot2::theme_set(theme_minimal()) # Ajustando Tema

dados_analise <- read.csv2("includes/nba.csv", sep = ";") 

dados_analise <- dados_analise |>
  mutate(
    across(c(PTS, AGE, AST, REB, TOV, BLK, FG_PCT, FG3_PCT, FT_PCT), as.numeric),
    Position = as.factor(Position)
  ) |>
  dplyr::select(-TEAM_ABBREVIATION, -PLAYER_NAME)



```



##  Motivação da Segunda Modelagem


## Definição da Variável Resposta

### Conceito de Backcourt e Frontcourt

No contexto deste estudo, os jogadores são classificados de acordo com sua função predominante em quadra:

- **Backcourt**: jogadores com maior responsabilidade na condução de bola, criação ofensiva e organização do jogo, tipicamente associados às posições de armador (PG) e ala-armador (SG).

- **Frontcourt**: jogadores com atuação predominante próxima à cesta, maior presença física e participação em ações como rebotes e proteção de aro, geralmente associados às posições de ala (SF), ala-pivô (PF) e pivô (C).

Essa distinção prioriza aspectos funcionais em detrimento de rótulos posicionais rígidos.

### Construção da Variável

A variável resposta foi construída a partir da posição original do jogador, utilizando a seguinte regra de mapeamento:

- PG e SG → Backcourt  
- SF, PF e C → Frontcourt  

Essa transformação permite reestruturar o problema de classificação em um cenário binário, mantendo coerência com o papel desempenhado pelos atletas em quadra.



```{r}

dados_analise <- dados_analise %>%
  mutate(
    Court = factor(case_when(
      Position %in% c("PG", "SG") ~ "Backcourt",
      Position %in% c("SF", "PF", "C") ~ "Frontcourt",
    )
  )) |>
  dplyr::select(-Position)



```


## Preparação dos Dados Com a Nova Variável

- Divisão: 70% treino e 30% teste
- Variável resposta: **Court**


```{r}

set.seed(16723)

dados_analise_split <- initial_split(dados_analise, prop = .7, strata = Court)
train_data <- training(dados_analise_split)
test_data <- testing(dados_analise_split)


```


## Ajuste do Modelo

Utilizando os mesmos *feature engineering* do primeiro modelo


### Pré-Processamento

```{r}

dados_analise_rec <- recipe(Court ~ ., data = train_data) |>
  
  step_mutate(
    AST_TOV_RATIO = AST / (TOV + 0.1),
    REB_HEIGHT_INTER = REB * Altura,
    PLAYMAKER_SCORE = AST - TOV,
    RIM_PROTECT = REB + BLK,
    PTS_EFF = PTS * FG_PCT) |>  
  step_YeoJohnson(all_numeric_predictors()) |> # Transformação Yeo-Johnson
  step_normalize(all_numeric_predictors()) |> # normaliza variáveis numéricas para terem média 0 e variância 1
  step_corr(all_numeric_predictors(), threshold = 0.8,
            method = "spearman"
  ) # remove preditores que tenham alta correlação com algum outro preditor

```



```{r}

prepped_data <- dados_analise_rec |> # usa a receita
  prep() |> # aplica a receita no conjunto de treinamento
  juice()# extrai apenas o dataframe preprocessado

```


### Conjunto de Validação

Utilizando o método *k-fold cross validation* para construir um conjunto de validação com *k-folds*. Considerando *k = 10*.

```{r}

cv_folds <- vfold_cv(train_data, v = 10, strata = Court)

```


### Otimização de Hiperparâmetros



```{r}

knn_spec <- nearest_neighbor(neighbors = tune()) %>% # K-NN
  set_engine("kknn")%>%
  set_mode("classification")

nbayes_spec <- naive_Bayes() %>% # Naive Bayes
  set_engine("naivebayes") %>%
  set_mode("classification")


logistic_spec <- logistic_reg() %>% # RL
  set_engine(engine = "glm") %>%
  set_mode("classification")

lda_spec <- discrim_linear() %>% # Linear discriminant analysis
  set_engine("MASS") %>%
  set_mode("classification")

qda_spec <- discrim_quad() %>% # Quadratic discriminant analysis
  set_engine("MASS") %>%
  set_mode("classification")


```

```{r}

wf = workflow_set(
  preproc = list(dados_analise_rec),
  models = list(
    knn_fit = knn_spec,
    nbayes_fit = nbayes_spec,
    linear_fit = logistic_spec,
    lda_fit = lda_spec,
    qda_fit = qda_spec
  )
) %>%
  mutate(wflow_id = gsub("(recipe_)", "", wflow_id))


```


```{r}

grid_ctrl = control_grid(
  save_pred = TRUE,
  parallel_over = "resamples",
  save_workflow = TRUE
)
grid_results = wf %>%
  workflow_map(
    seed = 16723,
    resamples = cv_folds,
    grid = 10,
    control = grid_ctrl
  )

```

Usando a acurácia no conjunto de validão de acordo com o melhor conjunto de hiperparâmetros obtido para cada modelo.

```{r}

autoplot(grid_results, metric = "accuracy")

```

Ordenando pelos melhores

```{r}

autoplot(grid_results, select_best = TRUE ,metric = "accuracy")

```

Utilizando outras métricas para avaliar

```{r}

autoplot(grid_results)

```

Ordenando os modelos pela métrica de acurácia no conjunto de Validação

```{r}

results_acc = workflowsets::rank_results(grid_results,
                                         select_best = TRUE,
                                         rank_metric = "accuracy") %>%
  filter(.metric == "accuracy") %>%
  dplyr::select(wflow_id, mean, std_err, model, rank)
results_acc %>% gt()

```

Escolhendo o melhor conjunto de hiperparâmetros para cada modelo de acordo com a acurácia no conjunto de validação.

```{r}

best_set_linear = grid_results %>% 
  extract_workflow_set_result("linear_fit") %>% 
  select_best(metric = "accuracy")
best_set_knn = grid_results %>% 
  extract_workflow_set_result("knn_fit") %>% 
  select_best(metric = "accuracy")
best_set_nbayes = grid_results %>%
  extract_workflow_set_result("nbayes_fit") %>% 
  select_best(metric = "accuracy")
best_set_lda = grid_results %>% 
  extract_workflow_set_result("lda_fit") %>% 
  select_best(metric = "accuracy")
best_set_qda = grid_results %>% 
  extract_workflow_set_result("qda_fit") %>% 
  select_best(metric = "accuracy")

```


## Avaliação dos modelos no conjunto de teste


```{r}

test_results <- function(rc_rslts, fit_obj, par_set, split_obj) {
  res <- rc_rslts %>%
    extract_workflow(fit_obj) %>%
    finalize_workflow(par_set) %>%
    last_fit(split = split_obj,
             metrics = metric_set(
               accuracy,roc_auc,
               f_meas,precision,
               recall,spec,kap))
  res
}


```

```{r}

test_results_linear = test_results(grid_results,"linear_fit",best_set_linear,dados_analise_split)
test_results_knn = test_results(grid_results,"knn_fit",best_set_knn,dados_analise_split)
test_results_nbayes = test_results(grid_results,"nbayes_fit",best_set_nbayes,dados_analise_split)
test_results_lda = test_results(grid_results,"lda_fit",best_set_lda,dados_analise_split)
test_results_qda = test_results(grid_results,"qda_fit",best_set_qda,dados_analise_split)


```


```{r}

metrics_table = rbind(
  collect_metrics(test_results_linear)$.estimate,
  collect_metrics(test_results_knn)$.estimate,
  collect_metrics(test_results_nbayes)$.estimate,
  collect_metrics(test_results_lda)$.estimate,
  collect_metrics(test_results_qda)$.estimate
)

metrics_table <- round(metrics_table, 4)
rnms = c("logistic_reg","k_nn","naive_bayes", "lin_discr","quad_discr")
metrics_table <- cbind(rnms, metrics_table)
metrics_table <- metrics_table %>% dplyr::as_tibble()


```


```{r}

colnames(metrics_table) = c("method","acc","roc_auc","f_meas",
                            "precision","recall","spec","kappa")


```


```{r}


metrics_table %>%
  arrange(desc(acc),desc(roc_auc),desc(f_meas),desc(kappa)) %>%
  gt()

```